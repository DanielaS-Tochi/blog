import { c as createComponent, r as renderTemplate, f as renderComponent, u as unescapeHTML } from './astro_BxpB7VFX.mjs';
import 'kleur/colors';
import { $ as $$BlogPostLayout } from './BlogPostLayout_DMSB9saN.mjs';

const html = "<p><strong>JavaScript</strong> no deja de evolucionar y todos los años se añaden nuevas funcionalidades para mejorar la productividad de los desarrolladores. Este año <strong>2021 no iba a ser una excepción</strong> y te explico las nuevas características que ya tienes disponible en la mayoría de navegadores.</p>\n<h2 id=\"1-logical-assignment-operators--\">1. Logical Assignment Operators (&#x26;&#x26;= ||= ??=)</h2>\n<p>Los operadores lógicos <code>&#x26;&#x26;</code>, <code>||</code> y <code>??</code> ahora también pueden usarse para asignar valores de una forma más sencilla y corta. Perfecto para asignar valores por defecto a variables.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Si x es falsy, se le asigna y</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">x </span><span style=\"color:#F97583\">||=</span><span style=\"color:#E1E4E8\"> y;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Equivale a...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">x </span><span style=\"color:#F97583\">||</span><span style=\"color:#E1E4E8\"> (x </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> y);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Si x es truthy, se le asigna y</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">x </span><span style=\"color:#F97583\">&#x26;&#x26;=</span><span style=\"color:#E1E4E8\"> y;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Equivale a...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">x </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> (x </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> y);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Si x es null o undefined, se le asigna y</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">x </span><span style=\"color:#F97583\">??=</span><span style=\"color:#E1E4E8\"> y;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Equivale a...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">x </span><span style=\"color:#F97583\">??</span><span style=\"color:#E1E4E8\"> (x </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> y);</span></span>\n<span class=\"line\"></span></code></pre>\n<p>Hay que tener en cuenta que en estas asignaciones, además, entra el juego la evaluación <em>short-circui</em>t. Esto quiere decir que estas asignaciones lógicas se evaluan de izquierda a derecha. <strong>Si una expresión lógica no se cumple, no se evalúa la siguiente.</strong></p>\n<p>Esto es importante para no cometer errores:</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#6A737D\">// este nuevo tipo de asignación con &#x26;&#x26;</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">x </span><span style=\"color:#F97583\">&#x26;&#x26;=</span><span style=\"color:#E1E4E8\"> y;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ✅ es equivalente a...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">x </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> (x </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> y);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ❌ NO es equivalente a...</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">x </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> x </span><span style=\"color:#F97583\">&#x26;&#x26;</span><span style=\"color:#E1E4E8\"> y;</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ya que la asignación ocurre siempre independientemente de la evaluación</span></span>\n<span class=\"line\"></span></code></pre>\n<h2 id=\"2-numeric-separator\">2. Numeric Separator</h2>\n<p>Leer algunas cifras en JavaScript puede ser una tarea difícil. Para solucionar esto, el nuevo separador numérico <code>_</code> te permite identificar de manera más sencilla cualquier número.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Es difícil saber qué cifra representa</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">1000000000</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">19436871.42</span><span style=\"color:#E1E4E8\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ¡Con Numeric Separator es más fácil!</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">1_000_000_000</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// Ah, es mil millones</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">100_000_000</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// Y esto es cien millones</span></span>\n<span class=\"line\"><span style=\"color:#79B8FF\">19_436_871.42</span><span style=\"color:#E1E4E8\">; </span><span style=\"color:#6A737D\">// ¡De un vistazo!</span></span>\n<span class=\"line\"></span></code></pre>\n<h2 id=\"3-promiseany\">3. Promise.any</h2>\n<p>¿Alguna vez has querido esperar una lista de promesas y que, al resolverse correctamente una cualquiera, continuar con la ejecución de tu código? Pues para eso se incorpora <strong>Promise.any()</strong>.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> promises</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> [</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  fetch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/from-external-api\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  fetch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/from-memory\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#B392F0\">  fetch</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"/from-new-api\"</span><span style=\"color:#E1E4E8\">),</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">];</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#F97583\">try</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // espera a la primera respuesta correcta que termine</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">  const</span><span style=\"color:#79B8FF\"> first</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> await</span><span style=\"color:#79B8FF\"> Promise</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">any</span><span style=\"color:#E1E4E8\">(promises);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // La más rápida fue la de memoria</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(first); </span><span style=\"color:#6A737D\">// respuesta desde 'from-memory'</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">catch</span><span style=\"color:#E1E4E8\"> (error) {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // ¡Todas las promesas han fallado!</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">assert</span><span style=\"color:#E1E4E8\">(error </span><span style=\"color:#F97583\">instanceof</span><span style=\"color:#B392F0\"> AggregateError</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // Log the rejection values:</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(error.errors);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // → [</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  //     &#x3C;TypeError: Failed to fetch /from-external-api>,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  //     &#x3C;TypeError: Failed to fetch /from-memory>,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  //     &#x3C;TypeError: Failed to fetch /from-new-api></span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  //   ]</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span></code></pre>\n<h3 id=\"aggregateerror\">AggregateError</h3>\n<p>Como has podido ver en el ejemplo anterior, ahora cuando la promesa falla, se devuelve una instancia de <code>AggregateError</code>. Este error es una instancia de <code>Error</code> y tiene una propiedad llamada <code>errors</code> que contiene una lista de errores para cada promesa que falló.</p>\n<h3 id=\"la-diferencia-con-promiserace\">La diferencia con <code>Promise.race</code>…</h3>\n<p><code>Promise.race</code> y <code>Promise.any</code> son muy similares. La diferencia es que <code>Promise.race</code> se resuelve cuando cualquier promesa ha sido <em>resuelta</em> o <em>rechazada</em>. En cambio <code>Promise.any</code> ignora las promesas que son rechazadas y sólo se resuelve cuando se resuelve la primera… o se rechaza cuando todas las promesas se han rechazado.</p>\n<h3 id=\"la-tabla-de-diferencias-de-promise\">La tabla de diferencias de <code>Promise</code></h3>\n<p>Para que lo veas más claro, he preparado una pequeña tabla para diferenciar los diferentes métodos de Promise a la hora de trabajar con un array de promesas, para que eligas la que más encaje con tu caso de uso.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"plaintext\"><code><span class=\"line\"><span>+−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−-−+−−−−−−−−−−−−−−−-−+</span></span>\n<span class=\"line\"><span>| Método             | Descripción                                      | Añadida en...   |</span></span>\n<span class=\"line\"><span>+−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−-−+−−−−−−−−−−−−−−−−-+</span></span>\n<span class=\"line\"><span>| Promise.allSettled | Espera a todas las promesas se resuelvan o no    | ES2020          |</span></span>\n<span class=\"line\"><span>| Promise.all        | Se para cuando una promesa es rechazada          | ES2015          |</span></span>\n<span class=\"line\"><span>| Promise.race       | Se para cuando una promesa es rechaza o resuelta | ES2015          |</span></span>\n<span class=\"line\"><span>| Promise.any        | Se para cuando una promesa es resuelta           | ES2021          |</span></span>\n<span class=\"line\"><span>+−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−-−−−+−−−−−−−−−−−−−−−-−+</span></span>\n<span class=\"line\"><span></span></span></code></pre>\n<h2 id=\"4-replaceall\">4. replaceAll</h2>\n<p>Hasta ahora, reemplazar todas las <em>instancias</em> de una cadena de texto en una cadena de texto te obligaba a usar <code>Regex</code> ya que <code>replace</code>, si le pasabas un <em>string</em>, lo que hacía era sólo reemplazar la primera instancia encontrada.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#6A737D\">// ¡Quiero cambiar las manzanas por bananas!</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"🍏🍏🍋🍋🍊🍊\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">replace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"🍏\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"🍌\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Pero qué...</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// -> '🍌🍏🍋🍋🍊🍊'</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ¡Tienes que usar Regex para conseguirlo!</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"🍏🍏🍋🍋🍊🍊\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">replace</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#DBEDFF\">🍏</span><span style=\"color:#9ECBFF\">/</span><span style=\"color:#F97583\">g</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"🍌\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// ¡Hasta ahora! ¡Hola replaceAll!</span></span>\n<span class=\"line\"><span style=\"color:#9ECBFF\">\"🍏🍏🍋🍋🍊🍊\"</span><span style=\"color:#E1E4E8\">.</span><span style=\"color:#B392F0\">replaceAll</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"🍏\"</span><span style=\"color:#E1E4E8\">, </span><span style=\"color:#9ECBFF\">\"🍌\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"></span></code></pre>\n<p><code>replaceAll</code> queda mucho más legible en nuestro código y hace justo lo que esperaba: cambiar todas las <em>instancias</em> de una cadena de texto en una cadena de texto.</p>\n<h2 id=\"5-weakref\">5. WeakRef</h2>\n<p><code>WeakRef</code> te permite crear una referencia débil a un objeto para no prevenir que se destruya por el <em>Garbage Collector</em> de JavaScript. ¿Por qué? Pues por qué cuando creamos un objeto, especialmente si son grandes, estos no son automáticamente destruidos por el <em>Garbage Collector</em> si existe una referencia a ellos.</p>\n<p>Con el método <code>deref</code> de <code>WeakRef</code>, podemos acceder a la referencia del objeto. Si la referencia al objeto ha sido eliminada, se devuelve <code>undefined</code>.</p>\n<pre class=\"astro-code github-dark\" style=\"background-color:#24292e;color:#e1e4e8; overflow-x: auto;\" tabindex=\"0\" data-language=\"javascript\"><code><span class=\"line\"><span style=\"color:#6A737D\">// Al crear un objeto...</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">let</span><span style=\"color:#E1E4E8\"> coords </span><span style=\"color:#F97583\">=</span><span style=\"color:#E1E4E8\"> { x: </span><span style=\"color:#79B8FF\">13</span><span style=\"color:#E1E4E8\">, y: </span><span style=\"color:#79B8FF\">72</span><span style=\"color:#E1E4E8\"> };</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Mientras tengas acceso a él directamente,</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// el objeto no será liberado de memoria</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// por el Garbage Collector</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Ahora podemos crear una referencia débil al objeto</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> weakCoords</span><span style=\"color:#F97583\"> =</span><span style=\"color:#F97583\"> new</span><span style=\"color:#B392F0\"> WeakRef</span><span style=\"color:#E1E4E8\">(coords);</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"color:#6A737D\">// Recuperamos las propiedades del elemento</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">const</span><span style=\"color:#79B8FF\"> ref</span><span style=\"color:#F97583\"> =</span><span style=\"color:#E1E4E8\"> weakCoords.</span><span style=\"color:#B392F0\">deref</span><span style=\"color:#E1E4E8\">();</span></span>\n<span class=\"line\"><span style=\"color:#F97583\">if</span><span style=\"color:#E1E4E8\"> (ref) {</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"Todavía tenemos acceso a las coordenadas\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  ref.x; </span><span style=\"color:#6A737D\">// -> 13</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">} </span><span style=\"color:#F97583\">else</span><span style=\"color:#E1E4E8\"> {</span></span>\n<span class=\"line\"><span style=\"color:#6A737D\">  // ref es `undefined`</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">  console.</span><span style=\"color:#B392F0\">log</span><span style=\"color:#E1E4E8\">(</span><span style=\"color:#9ECBFF\">\"La referencia ha sido eliminada\"</span><span style=\"color:#E1E4E8\">);</span></span>\n<span class=\"line\"><span style=\"color:#E1E4E8\">}</span></span>\n<span class=\"line\"></span></code></pre>\n<blockquote>\n<p>Una cosa que debes tener en cuenta con <code>WeakRef</code> es que… seguramente <strong>es mejor si no lo usas</strong>. Esta funcionalidad está pensado para casos muy específicos que, en general, acabarán en librerías y frameworks. <strong>Está bien que conozcas su existencia pero los casos de uso son muy limitados.</strong> La recolección de basura en JavaScript puede variar mucho dependiendo del navegador, entorno y especificaciones del sistema.</p>\n</blockquote>";

				const frontmatter = {"layout":"../../layouts/BlogPostLayout.astro","title":"novedades de la última versión de JavaScript","date":"2021-08-07T00:00:00.000Z","description":"Descubre todas las novedades del lenguaje JavaScript para ser más productivo y sacarle todo el partido.","category":"JavaScript","author":"Hector Martin Dama"};
				const file = "/Users/hectormartindama/Dev/blog/src/content/blog/post-2.md";
				const url = undefined;
				function rawContent() {
					return "\n**JavaScript** no deja de evolucionar y todos los años se añaden nuevas funcionalidades para mejorar la productividad de los desarrolladores. Este año **2021 no iba a ser una excepción** y te explico las nuevas características que ya tienes disponible en la mayoría de navegadores.\n\n## 1. Logical Assignment Operators (&&= ||= ??=)\n\nLos operadores lógicos `&&`, `||` y `??` ahora también pueden usarse para asignar valores de una forma más sencilla y corta. Perfecto para asignar valores por defecto a variables.\n\n```javascript\n// Si x es falsy, se le asigna y\nx ||= y;\n// Equivale a...\nx || (x = y);\n\n// Si x es truthy, se le asigna y\nx &&= y;\n// Equivale a...\nx && (x = y);\n\n// Si x es null o undefined, se le asigna y\nx ??= y;\n// Equivale a...\nx ?? (x = y);\n```\n\nHay que tener en cuenta que en estas asignaciones, además, entra el juego la evaluación *short-circui*t. Esto quiere decir que estas asignaciones lógicas se evaluan de izquierda a derecha. **Si una expresión lógica no se cumple, no se evalúa la siguiente.**\n\nEsto es importante para no cometer errores:\n\n```javascript\n// este nuevo tipo de asignación con &&\nx &&= y;\n// ✅ es equivalente a...\nx && (x = y);\n// ❌ NO es equivalente a...\nx = x && y;\n// ya que la asignación ocurre siempre independientemente de la evaluación\n```\n\n## 2. Numeric Separator\n\nLeer algunas cifras en JavaScript puede ser una tarea difícil. Para solucionar esto, el nuevo separador numérico `_` te permite identificar de manera más sencilla cualquier número.\n\n```javascript\n// Es difícil saber qué cifra representa\n1000000000;\n19436871.42;\n\n// ¡Con Numeric Separator es más fácil!\n1_000_000_000; // Ah, es mil millones\n100_000_000; // Y esto es cien millones\n19_436_871.42; // ¡De un vistazo!\n```\n\n## 3. Promise.any\n\n¿Alguna vez has querido esperar una lista de promesas y que, al resolverse correctamente una cualquiera, continuar con la ejecución de tu código? Pues para eso se incorpora **Promise.any()**.\n\n```javascript\nconst promises = [\n  fetch(\"/from-external-api\"),\n  fetch(\"/from-memory\"),\n  fetch(\"/from-new-api\"),\n];\n\ntry {\n  // espera a la primera respuesta correcta que termine\n  const first = await Promise.any(promises);\n  // La más rápida fue la de memoria\n  console.log(first); // respuesta desde 'from-memory'\n} catch (error) {\n  // ¡Todas las promesas han fallado!\n  console.assert(error instanceof AggregateError);\n  // Log the rejection values:\n  console.log(error.errors);\n  // → [\n  //     <TypeError: Failed to fetch /from-external-api>,\n  //     <TypeError: Failed to fetch /from-memory>,\n  //     <TypeError: Failed to fetch /from-new-api>\n  //   ]\n}\n```\n\n### AggregateError\n\nComo has podido ver en el ejemplo anterior, ahora cuando la promesa falla, se devuelve una instancia de `AggregateError`. Este error es una instancia de `Error` y tiene una propiedad llamada `errors` que contiene una lista de errores para cada promesa que falló.\n\n### La diferencia con `Promise.race`...\n\n`Promise.race` y `Promise.any` son muy similares. La diferencia es que `Promise.race` se resuelve cuando cualquier promesa ha sido _resuelta_ o _rechazada_. En cambio `Promise.any` ignora las promesas que son rechazadas y sólo se resuelve cuando se resuelve la primera... o se rechaza cuando todas las promesas se han rechazado.\n\n### La tabla de diferencias de `Promise`\n\nPara que lo veas más claro, he preparado una pequeña tabla para diferenciar los diferentes métodos de Promise a la hora de trabajar con un array de promesas, para que eligas la que más encaje con tu caso de uso.\n\n```\n+−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−-−+−−−−−−−−−−−−−−−-−+\n| Método             | Descripción                                      | Añadida en...   |\n+−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−-−+−−−−−−−−−−−−−−−−-+\n| Promise.allSettled | Espera a todas las promesas se resuelvan o no    | ES2020          |\n| Promise.all        | Se para cuando una promesa es rechazada          | ES2015          |\n| Promise.race       | Se para cuando una promesa es rechaza o resuelta | ES2015          |\n| Promise.any        | Se para cuando una promesa es resuelta           | ES2021          |\n+−−−−−−−−−−−−−−−−−−−−+−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−−-−−−+−−−−−−−−−−−−−−−-−+\n```\n\n## 4. replaceAll\n\nHasta ahora, reemplazar todas las _instancias_ de una cadena de texto en una cadena de texto te obligaba a usar `Regex` ya que `replace`, si le pasabas un _string_, lo que hacía era sólo reemplazar la primera instancia encontrada.\n\n```javascript\n// ¡Quiero cambiar las manzanas por bananas!\n\"🍏🍏🍋🍋🍊🍊\".replace(\"🍏\", \"🍌\");\n// Pero qué...\n// -> '🍌🍏🍋🍋🍊🍊'\n\n// ¡Tienes que usar Regex para conseguirlo!\n\"🍏🍏🍋🍋🍊🍊\".replace(/🍏/g, \"🍌\");\n\n// ¡Hasta ahora! ¡Hola replaceAll!\n\"🍏🍏🍋🍋🍊🍊\".replaceAll(\"🍏\", \"🍌\");\n```\n\n`replaceAll` queda mucho más legible en nuestro código y hace justo lo que esperaba: cambiar todas las _instancias_ de una cadena de texto en una cadena de texto.\n\n## 5. WeakRef\n\n`WeakRef` te permite crear una referencia débil a un objeto para no prevenir que se destruya por el _Garbage Collector_ de JavaScript. ¿Por qué? Pues por qué cuando creamos un objeto, especialmente si son grandes, estos no son automáticamente destruidos por el _Garbage Collector_ si existe una referencia a ellos.\n\nCon el método `deref` de `WeakRef`, podemos acceder a la referencia del objeto. Si la referencia al objeto ha sido eliminada, se devuelve `undefined`.\n\n```javascript\n// Al crear un objeto...\nlet coords = { x: 13, y: 72 };\n// Mientras tengas acceso a él directamente,\n// el objeto no será liberado de memoria\n// por el Garbage Collector\n\n// Ahora podemos crear una referencia débil al objeto\nconst weakCoords = new WeakRef(coords);\n\n// Recuperamos las propiedades del elemento\nconst ref = weakCoords.deref();\nif (ref) {\n  console.log(\"Todavía tenemos acceso a las coordenadas\");\n  ref.x; // -> 13\n} else {\n  // ref es `undefined`\n  console.log(\"La referencia ha sido eliminada\");\n}\n```\n\n> Una cosa que debes tener en cuenta con `WeakRef` es que... seguramente **es mejor si no lo usas**. Esta funcionalidad está pensado para casos muy específicos que, en general, acabarán en librerías y frameworks. **Está bien que conozcas su existencia pero los casos de uso son muy limitados.** La recolección de basura en JavaScript puede variar mucho dependiendo del navegador, entorno y especificaciones del sistema.\n";
				}
				function compiledContent() {
					return html;
				}
				function getHeadings() {
					return [{"depth":2,"slug":"1-logical-assignment-operators--","text":"1. Logical Assignment Operators (&&= ||= ??=)"},{"depth":2,"slug":"2-numeric-separator","text":"2. Numeric Separator"},{"depth":2,"slug":"3-promiseany","text":"3. Promise.any"},{"depth":3,"slug":"aggregateerror","text":"AggregateError"},{"depth":3,"slug":"la-diferencia-con-promiserace","text":"La diferencia con Promise.race…"},{"depth":3,"slug":"la-tabla-de-diferencias-de-promise","text":"La tabla de diferencias de Promise"},{"depth":2,"slug":"4-replaceall","text":"4. replaceAll"},{"depth":2,"slug":"5-weakref","text":"5. WeakRef"}];
				}

				const Content = createComponent((result, _props, slots) => {
					const { layout, ...content } = frontmatter;
					content.file = file;
					content.url = url;

					return renderTemplate`${renderComponent(result, 'Layout', $$BlogPostLayout, {
								file,
								url,
								content,
								frontmatter: content,
								headings: getHeadings(),
								rawContent,
								compiledContent,
								'server:root': true,
							}, {
								'default': () => renderTemplate`${unescapeHTML(html)}`
							})}`;
				});

export { Content, compiledContent, Content as default, file, frontmatter, getHeadings, rawContent, url };
