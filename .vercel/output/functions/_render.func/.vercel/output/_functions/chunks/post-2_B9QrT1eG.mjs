const id = "post-2.md";
						const collection = "blog";
						const slug = "post-2";
						const body = "\n**JavaScript** no deja de evolucionar y todos los a√±os se a√±aden nuevas funcionalidades para mejorar la productividad de los desarrolladores. Este a√±o **2021 no iba a ser una excepci√≥n** y te explico las nuevas caracter√≠sticas que ya tienes disponible en la mayor√≠a de navegadores.\n\n## 1. Logical Assignment Operators (&&= ||= ??=)\n\nLos operadores l√≥gicos `&&`, `||` y `??` ahora tambi√©n pueden usarse para asignar valores de una forma m√°s sencilla y corta. Perfecto para asignar valores por defecto a variables.\n\n```javascript\n// Si x es falsy, se le asigna y\nx ||= y;\n// Equivale a...\nx || (x = y);\n\n// Si x es truthy, se le asigna y\nx &&= y;\n// Equivale a...\nx && (x = y);\n\n// Si x es null o undefined, se le asigna y\nx ??= y;\n// Equivale a...\nx ?? (x = y);\n```\n\nHay que tener en cuenta que en estas asignaciones, adem√°s, entra el juego la evaluaci√≥n *short-circui*t. Esto quiere decir que estas asignaciones l√≥gicas se evaluan de izquierda a derecha. **Si una expresi√≥n l√≥gica no se cumple, no se eval√∫a la siguiente.**\n\nEsto es importante para no cometer errores:\n\n```javascript\n// este nuevo tipo de asignaci√≥n con &&\nx &&= y;\n// ‚úÖ es equivalente a...\nx && (x = y);\n// ‚ùå NO es equivalente a...\nx = x && y;\n// ya que la asignaci√≥n ocurre siempre independientemente de la evaluaci√≥n\n```\n\n## 2. Numeric Separator\n\nLeer algunas cifras en JavaScript puede ser una tarea dif√≠cil. Para solucionar esto, el nuevo separador num√©rico `_` te permite identificar de manera m√°s sencilla cualquier n√∫mero.\n\n```javascript\n// Es dif√≠cil saber qu√© cifra representa\n1000000000;\n19436871.42;\n\n// ¬°Con Numeric Separator es m√°s f√°cil!\n1_000_000_000; // Ah, es mil millones\n100_000_000; // Y esto es cien millones\n19_436_871.42; // ¬°De un vistazo!\n```\n\n## 3. Promise.any\n\n¬øAlguna vez has querido esperar una lista de promesas y que, al resolverse correctamente una cualquiera, continuar con la ejecuci√≥n de tu c√≥digo? Pues para eso se incorpora **Promise.any()**.\n\n```javascript\nconst promises = [\n  fetch(\"/from-external-api\"),\n  fetch(\"/from-memory\"),\n  fetch(\"/from-new-api\"),\n];\n\ntry {\n  // espera a la primera respuesta correcta que termine\n  const first = await Promise.any(promises);\n  // La m√°s r√°pida fue la de memoria\n  console.log(first); // respuesta desde 'from-memory'\n} catch (error) {\n  // ¬°Todas las promesas han fallado!\n  console.assert(error instanceof AggregateError);\n  // Log the rejection values:\n  console.log(error.errors);\n  // ‚Üí [\n  //     <TypeError: Failed to fetch /from-external-api>,\n  //     <TypeError: Failed to fetch /from-memory>,\n  //     <TypeError: Failed to fetch /from-new-api>\n  //   ]\n}\n```\n\n### AggregateError\n\nComo has podido ver en el ejemplo anterior, ahora cuando la promesa falla, se devuelve una instancia de `AggregateError`. Este error es una instancia de `Error` y tiene una propiedad llamada `errors` que contiene una lista de errores para cada promesa que fall√≥.\n\n### La diferencia con `Promise.race`...\n\n`Promise.race` y `Promise.any` son muy similares. La diferencia es que `Promise.race` se resuelve cuando cualquier promesa ha sido _resuelta_ o _rechazada_. En cambio `Promise.any` ignora las promesas que son rechazadas y s√≥lo se resuelve cuando se resuelve la primera... o se rechaza cuando todas las promesas se han rechazado.\n\n### La tabla de diferencias de `Promise`\n\nPara que lo veas m√°s claro, he preparado una peque√±a tabla para diferenciar los diferentes m√©todos de Promise a la hora de trabajar con un array de promesas, para que eligas la que m√°s encaje con tu caso de uso.\n\n```\n+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí-‚àí+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí-‚àí+\n| M√©todo             | Descripci√≥n                                      | A√±adida en...   |\n+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí-‚àí+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí-+\n| Promise.allSettled | Espera a todas las promesas se resuelvan o no    | ES2020          |\n| Promise.all        | Se para cuando una promesa es rechazada          | ES2015          |\n| Promise.race       | Se para cuando una promesa es rechaza o resuelta | ES2015          |\n| Promise.any        | Se para cuando una promesa es resuelta           | ES2021          |\n+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí-‚àí‚àí‚àí+‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí‚àí-‚àí+\n```\n\n## 4. replaceAll\n\nHasta ahora, reemplazar todas las _instancias_ de una cadena de texto en una cadena de texto te obligaba a usar `Regex` ya que `replace`, si le pasabas un _string_, lo que hac√≠a era s√≥lo reemplazar la primera instancia encontrada.\n\n```javascript\n// ¬°Quiero cambiar las manzanas por bananas!\n\"üçèüçèüçãüçãüçäüçä\".replace(\"üçè\", \"üçå\");\n// Pero qu√©...\n// -> 'üçåüçèüçãüçãüçäüçä'\n\n// ¬°Tienes que usar Regex para conseguirlo!\n\"üçèüçèüçãüçãüçäüçä\".replace(/üçè/g, \"üçå\");\n\n// ¬°Hasta ahora! ¬°Hola replaceAll!\n\"üçèüçèüçãüçãüçäüçä\".replaceAll(\"üçè\", \"üçå\");\n```\n\n`replaceAll` queda mucho m√°s legible en nuestro c√≥digo y hace justo lo que esperaba: cambiar todas las _instancias_ de una cadena de texto en una cadena de texto.\n\n## 5. WeakRef\n\n`WeakRef` te permite crear una referencia d√©bil a un objeto para no prevenir que se destruya por el _Garbage Collector_ de JavaScript. ¬øPor qu√©? Pues por qu√© cuando creamos un objeto, especialmente si son grandes, estos no son autom√°ticamente destruidos por el _Garbage Collector_ si existe una referencia a ellos.\n\nCon el m√©todo `deref` de `WeakRef`, podemos acceder a la referencia del objeto. Si la referencia al objeto ha sido eliminada, se devuelve `undefined`.\n\n```javascript\n// Al crear un objeto...\nlet coords = { x: 13, y: 72 };\n// Mientras tengas acceso a √©l directamente,\n// el objeto no ser√° liberado de memoria\n// por el Garbage Collector\n\n// Ahora podemos crear una referencia d√©bil al objeto\nconst weakCoords = new WeakRef(coords);\n\n// Recuperamos las propiedades del elemento\nconst ref = weakCoords.deref();\nif (ref) {\n  console.log(\"Todav√≠a tenemos acceso a las coordenadas\");\n  ref.x; // -> 13\n} else {\n  // ref es `undefined`\n  console.log(\"La referencia ha sido eliminada\");\n}\n```\n\n> Una cosa que debes tener en cuenta con `WeakRef` es que... seguramente **es mejor si no lo usas**. Esta funcionalidad est√° pensado para casos muy espec√≠ficos que, en general, acabar√°n en librer√≠as y frameworks. **Est√° bien que conozcas su existencia pero los casos de uso son muy limitados.** La recolecci√≥n de basura en JavaScript puede variar mucho dependiendo del navegador, entorno y especificaciones del sistema.\n";
						const data = {layout:"../../layouts/BlogPostLayout.astro",title:"novedades de la √∫ltima versi√≥n de JavaScript",date:new Date(1628294400000),description:"Descubre todas las novedades del lenguaje JavaScript para ser m√°s productivo y sacarle todo el partido.",category:"JavaScript",author:"Hector Martin Dama"};
						const _internal = {
							type: 'content',
							filePath: "/Users/hectormartindama/Dev/blog/src/content/blog/post-2.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
